\documentclass[11pt,letterpaper]{article}
\usepackage[top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[most]{tcolorbox}
\usepackage[spaces,hyphens]{url}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage{pdfpages}
\usepackage{xcolor}
\usepackage{textcomp}

\definecolor{Darkgreen}{rgb}{0,0.4,0}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
backgroundcolor=\color{lbcolor},
    tabsize=4,    
%   rulecolor=,
    language=[GNU]C++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}’.
}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{Darkgreen},
  stringstyle=\color{red},
  upquote=true
  }
\newtcblisting{commandshell}{colback=black,colupper=white,colframe=yellow!75!black,
listing only,listing options={language=sh},
every listing line={\textcolor{green}{\small\ttfamily\bfseries RodrigoMenacho \$> }}}


% Packages
\usepackage{amsmath}
\usepackage{graphicx}

% Document
\begin{document}
\begin{center}
    \textbf{Resumen C++}
\end{center}

\section{Class 1}
\subsection{Mejoras sobre C}
\begin{itemize}
    \item Existe la sobrecarga de funciones sin perder ningun recurso en memoria
    \item El include de las librerias no termina en .h \textbf{cstdio = stdio.h}
\end{itemize}
\subsection{Namespace}
Es un contenedor de identificador.
\begin{itemize}
    \item Variable
    \item Funciones
    \item Structs
    \item Clases
    \item Tipos Enum
    \item Namespaces
\end{itemize}
Desde Cpp-17 existes Namespaces anidados: \\
A::B::C
\subsection{Referencias}
\begin{quote}
    Son punteros disfrazados de ovejas.
\end{quote}
Porque internamente son punteros.
Limitaciones: 
\begin{itemize}
    \item Inmutables
    \begin{itemize}
        \item Establecida la referencia y su referido esa relacion no se puede cambiar
    \end{itemize}
    \item No hay aritmetica a referencias 
    \item Cuando se accede a la referencia se accede al valor del referido
    \item No hay referencias a NULL
\end{itemize}
\subsection{Scoped Enums}
\begin{lstlisting}[language=C++, caption={Scoped enums}]
enum class Priority
{
	RED, BLUE, BLACK;
};

enum class Color
{
	RED, GREEN, BLUE;
};
\end{lstlisting}

\section{Class 2}
\subsection{Clase y Struct}
En la clase todo es privado por defecto.\\
En el struct todo es publico por defecto.
\subsection{Const al final del metodo}
El const al final dice que no se modificara los atributos de la clase
y solo llama a metodos constantes.
\begin{lstlisting}[language=C++, caption={method() const}]
void mostrar() const
{
    printf("(%zu) %s %s\n",ci, ln, fn);
}
\end{lstlisting}
\subsection{This}
Es un puntero que representa la instancia.

\begin{lstlisting}[language=C++, caption={this->}]
Person(const char* fn, const char* ln, size_t ci)
{
    strcpy(this->fn, fn);
    strcpy(this->ln, ln);
    this->ci = ci;
}
\end{lstlisting}

\subsection{Inicializacion Uniforme}
Es por eso que se crea un objeto con llaves {} para que no se raye el compilador cuando lee parentesis, 
porque puede compilar como si fuese un metodo.

\begin{lstlisting}[language=C++, caption={Inicializacion con llaves}]
Person q{"Julian", "Assange", 1961};
\end{lstlisting}

\section{Class 3}
\subsection{Initialization List}
Cuando podemos inicializar los atributos de un constructor usando llaves dentro de la clase.
\begin{lstlisting}[language=C++, caption={Inicializacion con llaves en constructor}]
student(size_t id, const char *name)
    : id{id} //Initialization list
// forma preferida para inicializar atributos
{
    auto len = strlen(name);
    this->name = (char *)malloc(len + 1);
    memcpy(this->name, name, len + 1);
}
\end{lstlisting}

\subsection{Regla de 3}
Si existe un malloc es necesario que se reimplemente el destructor, constructor y el operador igual “=”
de una clase o struct para evitar problemas en compilacion.

\subsection{RAII}
\begin{quotation}
    \textbf{Resource adquisition is initialization}
\end{quotation}
Es decir, es una caracteristica en C++ donde el elemento que fue creado dentro de un cierto Scope
se destruye al salir de este scope.

\subsection{Copia}
\begin{lstlisting}[language=C++, caption={Copia}]
auto student z{2, "Antonio jose de sucre"};
auto q = z; // copy
\end{lstlisting}
\subsection{Asignacion}
\begin{lstlisting}[language=C++, caption={Asignacion}]
student r{666, "norbert"};
r = q; // Asignacion
\end{lstlisting}

\section{Class 4}
Se implemento la clase ztring xD.

\begin{lstlisting}[language=C++, caption={Clase Ztring}]
#include <cstdio>
#include <cstring>
#include <cstdlib>

constexpr size_t MAX = 16;

class ztring
{
    char* chars;
    // SSO: small string optimization
    char szo[MAX];
    size_t len;
    public:
    ztring(const char* s = "")
    :len{strlen(s)}
    {
        set_string(s);
    }
    const char* data() const
    {
        return len < MAX ? szo : chars;
    }
    ~ztring()
    {
        if (len >= MAX)
        {
            free(chars);
        }
    }
    ztring(const ztring& s)
    :len{s.len}
    {
        set_string(s.data());
    }

    ztring& operator=(const ztring& src)
    {
        if (this != &src)
        {
            return *this;
        }
        this->~ztring();
        len = src.len;
        set_string(src.data());
        return *this;
    }

    ztring operator+(const ztring& s) const
    {
        auto nlen = len + s.len;
        ztring ns;
        ns.len = nlen;
        if (nlen >= MAX)
        {
            ns.chars = (char*) malloc(nlen+1);
        }
        char* str = nlen < MAX ? ns.szo : ns.chars;
        memcpy(str, data(), len);
        memcpy(str + len, s.data(), s.len+1);
        return ns;

    }

    ztring& operator+=(const ztring& src)
    {
        auto nlen = len + src.len;
        if (len >= MAX)
        {
            chars = (char*) realloc(chars, nlen+1);
            memcpy(chars + len, src.data(), src.len+1);
            len = nlen;
            return *this;
        }

        if (nlen >= MAX)
        {
            chars = (char*) malloc(nlen+1);
            memcpy(chars, data(), len);
            memcpy(chars + len, src.data(), src.len+1);
            len = nlen;
            return *this;
        }
        memcpy(szo + len, src.data(), src.len+1);
        len = nlen;
        return *this;
    }

    private:
    void set_string(const char* s)
    {
        if (len >= MAX)
        {
            chars = (char*) malloc(len+1);
            memcpy(chars, s, len+1);
        }else
        {
            memcpy(szo, s, len+1);
        }
    }

};

\end{lstlisting}


\section{Class 5}
\subsection{Herencia}
La herencia se lo realiza con los \textbf{:} y se especifica
si es public, private or protected.
\begin{lstlisting}[language=C++, caption={Herencia}]
// si es private todo lo que se hereda, es privado hacia afuera
class student: public person 
{
}
\end{lstlisting}

\subsection{Hiding}
Cuando se da la herencia directamente no es posible el polimorfismo por lo cual
se da el siguiente caso donde se esconde el metodo del padre.
\begin{lstlisting}[language=C++, caption={Hiding}]
void print() const
{
    person::print(); // HIDING esconde el metodo de la clase padre
    printf(" Score %lu ", score);
}
\end{lstlisting}

\subsection{New}
El keyword new es una palabra reservada la cual nos permite crear objetos
del tipo punteros, el cual realiza el pedido de memoria en el HEAP de toda una 
clase o struct. \par
A su vez llama al constructor de la clase. 
\begin{lstlisting}[language=C++, caption={New}]
// auto* q = (point*) malloc(sizeof(point)); 
// no llama al constructor por lo que no sirve

point* q = new point(6, 9); // Pide en el HEAP pero es mas lento
// ***desventajas***
// No es posible usar aritmetica de punteros
// Ni realloc
\end{lstlisting}
Por cada \textbf{new} debe existir un \textbf{delete}, analogamente en c
por cada \textbf{malloc} existe un \textbf{free} 

\subsection{new[]}
Es posible inicializar array de objetos, indicando el numero de objetos que 
tendra el array.
\begin{lstlisting}[language=C++, caption={New[ ]}]
point* ps = new point[3];
// operador new[]
// std::bad_alloc es porque no encuentra espacio en memoria
ps[0].set_values(9,5);
ps[1].set_values(2,1);
ps[2].set_values(0,4);
for (size_t i = 0; i < 3; i++)
{
    ps[i].print();
}
delete[] ps;
\end{lstlisting}
Por cada \textbf{new[ ]} existe un \textbf{delete[ ]}.
\begin{quote}
    \textbf{NO OLVIDAR EL DELETE[ ]}
\end{quote}

\subsection{POD - Plain Old Data}
Hace referencia a:
\begin{itemize}
    \item Tipo primitivo
    \item Array de pods
    \item Structs de pods
    \item Union de pods
\end{itemize}
En el cual, para todos estos PODs es posible usar malloc, realloc and free.


\section{Class 6}
\subsection{Polimorfismo}
Sucede cuando dos instancias de dos subclases de una misma clase base,
al recibir un mismo mensaje, reaccionan de diferente manera. \par

\begin{quote}
    En cpp \textbf{mensaje} es igual a \textbf{metodo}.
\end{quote}
Se implementa de la siguiente manera.

\textbf{virtual} para especificar al compilador que el metodo se 
hara un \textbf{override}. 
\begin{lstlisting}[language=C++, caption={Metodo del Padre}]
virtual void print() const
{
    printf("(%lu) %s", id, name.c_str());
}
\end{lstlisting}

En el metodo del hijo, si se quiere hacer un metodo polimorfico se 
utiliza le keyword \textbf{override}.
\begin{lstlisting}[language=C++, caption={Metodo del Hijo}]
void print() const override
{
    person::print();
    printf(" Score %lu ", score);
}
\end{lstlisting}

\paragraph{Observaciones}
Si se pone virtual entonces se crea un puntero extra en tu objeto
 que se llama VTABLE
 que son tablas de elementos virtuales y crece en memoria
 Y llamar a mtodos virtuales cuesta:
\begin{quote}
    De un objeto-$>$vtable-$>$ejecutarMetodo
\end{quote}
 El compilador no tiene poder sobre el virtual.

\subsection{Clase Abstracta}
Las clases ABC.
\paragraph{Abstract Base Class} las cuales solo tienen firmas
menos el destructor.

Para declarar una clase abstracta solo es necesario igualar a 0 
un metodo y asi toda la clase se vuelve abstracta. \par
Es necesario considerar que las clases abstractas NO pueden ser instanciadas.
\begin{lstlisting}[language=C++, caption={Declaracion de clase abstracta}]
struct Animal
{
    virtual ~Animal(){};
    virtual void comunicarse() const = 0;
};
\end{lstlisting}

\section{Class 7}
En la clase se realizo una aplicacion de polimorfismo con clases abstractas.
Lo cual se mostrara todo el codigo en el appendix.
\subsection{static cast $<$$>$}
Es una forma mas sofisticada de castear, porque es mas legible 
por el programador, en lugar de el metodo clasico de casteo.
\begin{itemize}
    \item Lo peculiar de este es que realiza el casteo en tiempo de compilacion.
    \item No es posible realizar este tipo de casteo si se usa \textit{Herencia virtual}.
\end{itemize}
\begin{lstlisting}[language=C++, caption={static cast}]
return n == static_cast<const Integer&>(src).n;
\end{lstlisting}
\subsection{dynamic cast} 
Es un tipo de casteo dinamico que se realiza en tiempo de ejecucion, el cual
revisa en la VTABLE (lo que siginifica que al usarlo, por lo menos el objeto en 
cuestion deberia de tener un metodo virtual).
\begin{itemize}
    \item Si se castea con punteros entonces devuelve null si no pertenece a la herencia.
    \item Si se castea con referencias, cuando no es posible el casteo bota una excepcion.
\end{itemize}
\begin{lstlisting}[language=C++, caption={static cast}]
auto f = dynamic_cast<Integer*>(e);
\end{lstlisting}


\section{Class 8 - Herencia Multiple}
Se vio ejemplos de herencia multiple.

\begin{lstlisting}[language=C++, caption={Herencia multiple}]
struct IntChar : Int, Char
{
    IntChar(int n, char c)
    :Int{n}, Char{c}
    {
    }

    std::string to_string() const
    {
        auto s = Int::to_string();
        s += ",";
        s += Char::to_string();
        return s;
    }
};
\end{lstlisting}

\section{Class 9}
\subsection{Herencia virtual}
Herencia virtual es que discrimina metodos repetidos y quita la ambiguedad
si es que existen metodos ya implementados en jerarquias superiores.
\begin{lstlisting}[language=C++, caption={Herencia virtual}]
struct X
{
    int x;
    virtual ~X(){};
};
struct Y : virtual X
{
};
struct Z : virtual X
{
};
struct W final : Y, Z
{
};

// Con el keyword 'final' acaba la jerarquia
\end{lstlisting}


\section{Class 10}
\subsection{Excepciones}
Es un tipo de error el cual puede ser controlado mediante un
\textit{Exception Handler} (\textbf{Try-catch}) el cual trata la excepcion.\par
Si la excepcion no es trata por ningun \textit{Exception Handler} , entonces le programa termina.
\begin{itemize}
    \item NO se puede agarrar un Segmentation Fault.
    \item NO se puede agarrar errores Logicos.
\end{itemize}

\begin{lstlisting}[language=C++, caption={Excepciones}]
#include <cstdio>

void c()
{
    throw 214U;
    // int* q = nullptr;
    // *q += 18;
    // int x = 6, y = 0;
    // int z = x / y;
    // Segmentation fault no se puede agarrar
    // Tampoco errores logicos 
}

void b()
{
    puts("Starting b");
    c();
    puts("Ending b");
}

void a()
{
    puts("Stating a");
    b();
    puts("Ending a");
}


int main()
{
    try
    {
        a();
        puts("Happy bye");
    }
    catch(const char* e)
    {
        printf("Error: %s\n", e);
    }
    catch(int e)
    {
        printf("codigo: %d\n", e);
    }
    puts("Bye anyway");

}
\end{lstlisting}

\newpage
\appendix
\section{Ejemplos de Punteros y Referencias }
By Carlos, Marcela, Dani, Karen.
\input{examples.tex}

\section{Code of Class 2}
\input{a_class2.tex}

\section{Code of Class 3}
\input{a_class3.tex}

\section{Code of Class 4}
\input{a_class4.tex}

\section{Code of Class 5}
\input{a_class5.tex}

\section{Code of Class 6}
\input{a_class6.tex}

\section{Code of Class 7}
\input{a_class7.tex}

\section{Code of Class 8}
\input{a_class8.tex}

\section{Code of Class 9}
\input{a_class9.tex}

\section{Code of Class 10}
\input{a_class10.tex}

\end{document}